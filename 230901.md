目前大致看的几个比赛的模块，之后随时更新：

## Starry

https://gitlab.eduxiji.net/202310003101649/starry

测例差 cyclictest 其他都有

### 主要模块

##### axmem

除了页表之外，做了 sharememory 支持，对应 shmat maparea有 lazy alloc

##### axnet

贾两个月前的版本，陈嘉钰加了一些新特性
后续有可能回馈到 arceos 上吗？不能直接做，需要依赖他们自己的 axprocess，和 unikernel 冲突

##### axsignal

对 maturin 做了很不错的简化，虽说 axprocess 里的handle_signals()还是一样很长很复杂，但我也不知道有啥更好的写法

##### axtask
	
做了任务调度队列。印象里以前是要求过跟原本的 arceos 兼容的

##### axfs

还是用的rust-fatfs。在内核模拟了硬链接

##### axprocess

做了 futex

##### starry_libax

大部分的实现都在这里了，好处是这样底下 modules/ 的模块比较干净，坏处是它自己就很复杂了，比如 socket 部分连带了很多实现

##### 其他

沿用了 maturin 每次 syscall 进来一个用户地址就去查页表的习惯，其实不太好。我的问题

##### 模块依赖

用了贾的 crate_interface 所以还好

## Titanix

https://gitlab.eduxiji.net/202318123101314/oskernel2023-Titanix

是一等奖，他们说有全局 async，但具体的应用还没细看

### 主要模块

##### 地址空间

单页表、高地址空间启动
COW 他们自己说写了，但其实不对。他们新分出来的页会删去W位并通过页表打标记，但没有处理旧进程的页。如果fork之后旧进程先修改新进程再修改，这个实现就错了
为了这个COW他们还给每个物理页打了Arc，降低了效率

##### 用户地址检查

加了特殊的 trap_handler，每次要读写用户地址时就先切到这个 handler。它这个过程按理说是要关内核中断的，但全程没提，预计是内核默认全局关中断？
	
##### fs

加了文件名->inode 的 hash，而且是连带全路径的。maturin也做过。
FAT看起来像手搓

##### 信号

线程间信号用了类似 rcore-tutorial作业的"邮箱"实现， wait 套了层future的壳，但其实没有必要

##### 网络
基于 smoltcp 配置，形式支持 ipv4/ipv6，上层支持tcp/udp/unixsocket

##### 时间
所有需要使用的时间转换为 core::time::Duration，很方便，不错

### async 部分

##### 任务/线程
可超时，但需要每次执行完成后才判断超时(src/timer/timeout_task.rs)，这是可以理解的，毕竟目标不是 rtos

##### 特殊 syscall
ppoll pselect 的筛选fd过程被包装成了 poll。
这些 syscall 跟 sys_wait、网络部分都用到一个自定义的 `struct Select2Futures`

这个结构体定义为(f1,f2)，先 poll f1，成功了就返回 f1，然后poll f2，成功了就返回 f2，再失败就返回 pending。
这个结构体的应用场景是有一个正常需要做的 future，和一个 `current_task().wait_for_events(…)`，这样使用 `Select2Futures` 按顺序 poll 这俩，实际效果就是保证正常 future 允许被打断。

思考：
> 跟直接写一个上层 future 把这俩包一下相比，这样写好不好？现在 titanix 的写法相当于把每次这种类似的 future 包成同一个写法，省几行，但是 poll f1/f2 之后还要拿结果来 match 去区分到底是哪种情况，可能代码上还多一些。
> 
> 对于可中断任务，有没有更好的包装方法？“可中断任务”的语义能否定义为 `Select2Futures<f1, current_task().wait_for_events(…)>`，还是有其他定义

##### future 底层
网络依赖于 smoltcp 提供的 Socket::register_recv_waker
文件系统依赖于 mm/pages/load_buffer_if_needed() 中对 dyn Inode 的类型的 read，就比赛来说往下走到的 FAT32Inode 类型。这里没有真正的“异步”行为，也即没有使用非阻塞方式与sdcard互动。

虽然没有真正提高效率的协程，但按老师的思路来说，仅用协程来简化代码也算是协程的作用


## PLNTRY

https://gitlab.eduxiji.net/PLNTRY/OSKernel2023-umi 是西安交大做的，是特等奖

## byteos

https://gitlab.eduxiji.net/202310464101015/oskernel2023-byteos

## alien

https://gitlab.eduxiji.net/202310007101563/Alien

## zhongtianos

https://gitlab.eduxiji.net/202310006101080/zhongtianos
