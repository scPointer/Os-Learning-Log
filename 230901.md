目前大致看的几个比赛的模块，之后随时更新：


# 横向对比

尽量只简要描述，不粘代码

## 用户地址检查

### titanix

先修改 stvec，然后尝试每页读/写一个 u8 看会不会触发异常，触发了就打个标记。检查完再改回来。
这个方法确实可以，比较简便，但是最好在进入这套流程之前检查是否关闭内核中断

### PLNTRY

类似地，也是修改 stvec 检查完再改回来。
但和 titanix 不同的是，检查底层不是读/写，是`_checked_copy`和`_checked_zero`，即复制或清零。
这意味着 PLNTRY 中用户给的参数都是复制一份到内核中再操作的，很符合规范（如果不这样做，在 syscall 执行过程中用户给的地址上的东西可能被其他线程改掉），但比赛时性能上可能吃亏

## backtrace

rust 在 core::fmt::Display 里直接就有宏直接输出代码所在文件/行/列，方便debug：
```rust
file!()
line!()
column!()
```

### titanix

是一种主动的 backtrace，比较简单，但负担比较大：

在每个核上有一个 Vec 存调用的函数信息（叫 StackTracker），每次调用 stack_trace!() 宏时往里面 push 调用信息，函数退出时（事实上是这个宏构造了一个结构 StackInfoGuard，然后在函数退出时 Drop）pop 这一条信息，panic 时输出。
	
特点：
1. 需要手动调用 stack_trace!()，事实上大部分内核函数开头都加了这么一句。
2. 在每次调用时需要存信息(等价于`Option<&'static str>`)、文件名`&'static str`、行号(`u32`)，再加上 Vec 的一点点判断，开销比较大
即使把第一个 Option 简化为常量字符串也很多（因为`None`可以写成`""`，这也是一个合法的`&'static str`）。

## 异步部分

> 思考：协程的本质改进是“无栈”。
>
> 写协程的队伍很容易首先提到 poll 和 waker。一个事件返回 Poll::Pending 则需要等待，waker.wake() 则可唤醒等待中协程，即重新加入等待执行的队列。但这件事其实不需要协程，正常的 OS 也可以有这两个队列。更本质的特征是每个用户程序没有了内核栈，而是改成每个核有一个唯一的栈，至于运行到一半的用户程序怎么保存状态，就由 rust 的状态机自动管理了。

### titanix

##### 任务/线程
可超时，但需要每次执行完成后才判断超时(src/timer/timeout_task.rs)，这是可以理解的，毕竟目标不是 rtos

##### 特殊 syscall
ppoll pselect 的筛选fd过程被包装成了 poll。
这些 syscall 跟 sys_wait、网络部分都用到一个自定义的 `struct Select2Futures`

这个结构体定义为(f1,f2)，先 poll f1，成功了就返回 f1，然后poll f2，成功了就返回 f2，再失败就返回 pending。
这个结构体的应用场景是有一个正常需要做的 future，和一个 `current_task().wait_for_events(…)`，这样使用 `Select2Futures` 按顺序 poll 这俩，实际效果就是保证正常 future 允许被打断。

思考：
> 跟直接写一个上层 future 把这俩包一下相比，这样写好不好？现在 titanix 的写法相当于把每次这种类似的 future 包成同一个写法，省几行，但是 poll f1/f2 之后还要拿结果来 match 去区分到底是哪种情况，可能代码上还多一些。
> 
> 对于可中断任务，有没有更好的包装方法？“可中断任务”的语义能否定义为 `Select2Futures<f1, current_task().wait_for_events(…)>`，还是有其他定义

##### future 底层
网络依赖于 smoltcp 提供的 Socket::register_recv_waker
文件系统依赖于 mm/pages/load_buffer_if_needed() 中对 dyn Inode 的类型的 read，就比赛来说往下走到的 FAT32Inode 类型。这里没有真正的“异步”行为，也即没有使用非阻塞方式与sdcard互动。

虽然没有真正提高效率的协程，但按老师的思路来说，仅用协程来简化代码也算是协程的作用

### PLNTRY

比较复杂，还没看

### byteos

还没看

### Alien

仅有 UART 串口是异步的

# 各内核大致模块情况

## Starry

https://gitlab.eduxiji.net/202310003101649/starry

测例差 cyclictest 其他都有

### 主要模块

##### axmem

除了页表之外，做了 sharememory 支持，对应 shmat maparea有 lazy alloc

##### axnet

贾两个月前的版本，陈嘉钰加了一些新特性
后续有可能回馈到 arceos 上吗？不能直接做，需要依赖他们自己的 axprocess，和 unikernel 冲突

##### axsignal

对 maturin 做了很不错的简化，虽说 axprocess 里的handle_signals()还是一样很长很复杂，但我也不知道有啥更好的写法

##### axtask
	
做了任务调度队列。印象里以前是要求过跟原本的 arceos 兼容的

##### axfs

还是用的rust-fatfs。在内核模拟了硬链接

##### axprocess

做了 futex

##### starry_libax

大部分的实现都在这里了，好处是这样底下 modules/ 的模块比较干净，坏处是它自己就很复杂了，比如 socket 部分连带了很多实现

##### 其他

沿用了 maturin 每次 syscall 进来一个用户地址就去查页表的习惯，其实不太好。我的问题

##### 模块依赖

用了贾的 crate_interface 所以还好

## Titanix

https://gitlab.eduxiji.net/202318123101314/oskernel2023-Titanix

是一等奖，他们说有全局 async，但具体的应用还没细看

### 主要模块

##### 地址空间

单页表、高地址空间启动
COW 他们自己说写了，但其实不对。他们新分出来的页会删去W位并通过页表打标记，但没有处理旧进程的页。如果fork之后旧进程先修改新进程再修改，这个实现就错了
为了这个COW他们还给每个物理页打了Arc，降低了效率

##### 用户地址检查

加了特殊的 trap_handler，每次要读写用户地址时就先切到这个 handler。它这个过程按理说是要关内核中断的，但全程没提，预计是内核默认全局关中断？
	
##### fs

加了文件名->inode 的 hash，而且是连带全路径的。maturin也做过。
FAT看起来像手搓

##### 信号

线程间信号用了类似 rcore-tutorial作业的"邮箱"实现， wait 套了层future的壳，但其实没有必要

##### 网络
基于 smoltcp 配置，形式支持 ipv4/ipv6，上层支持tcp/udp/unixsocket

##### 时间
所有需要使用的时间转换为 core::time::Duration，很方便，不错

## PLNTRY

https://gitlab.eduxiji.net/PLNTRY/OSKernel2023-umi 是西安交大做的，是特等奖

内核页表：目前还没有看到，似乎只有启动时给的几个大页。启动时只是初始化了栈 / bss / 堆 / trap 等信息，没有给内核换一个页表，这样内核的读写执行权限不够严，可能出现内核栈越界了但没有 guard page 拦着、pc跑飞了直接改text段等问题。

## byteos

https://gitlab.eduxiji.net/202310464101015/oskernel2023-byteos

## alien

https://gitlab.eduxiji.net/202310007101563/Alien

## zhongtianos

https://gitlab.eduxiji.net/202310006101080/zhongtianos
