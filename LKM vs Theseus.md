# 对比

相比 Linux Kernel Module， Theseus 的模块动态加载要更强一些，支持部分新的特性

theseus 手动实现了部分链接器的功能，可以查找符号
LKM 只允许查找标记为 exported 的符号。当然这只是linux权限控制更强，而不是功能更弱

LKM 似乎是普通的运行时动态加载，theseus 是运行时手动查表，因而可以实现模块替换

此处的模块替换是指两个模块，其中a依赖b，此时可以b卸载后重新加载一个版本，a仍然能访问b。

在通常的运行时动态加载中，使用了地址无关代码PIC来进行访问，其中会用到一个lazy binding来做运行时的间接寻址
例如，
第一次调用函数foo时，会先调用 `PLT[n]`，然后跳转到 `*GOT[n]`
发现 `GOT[n]` 为空后，会调用动态链接器去查全局符号表，填`GOT[n]`
之后就可以通过 `GOT[n]` 调用了，不用再查符号表

但重新加载后，a不知道这个事，`GOT[n]` 仍存在，(普通的运行时动态加载)就可能访问到非法地址。而theseus是手动通过(rust代码写的)Trie树去查的符号表，就没有这个问题，当然这样慢很多

### LKM 基本特征

- 没有垃圾回收，需要手动释放资源
- 没有printf，可以通过printk输出
- 可能同时被多个进程使用，必须考虑一致性
- 分配给内核模块的执行时间通常比用户程序多
- 不支持浮点

和普通用户程序对比，主要使用 `<linux/init.h>` 和 `<linux/module.h>`，可通过 EXPORT_SYMBOL 导出符号，加载后的加载的LKM动态链接到内核中

通常用途

- 设备和网络驱动
- 文件系统驱动
- 重写syscall
- 翻译器

### LKM 动态加载细节

LKM仅可使用 exported 的符号，而内核的所有符号分三种
- static 仅在自己的源文件中可见
- external 对内核本身内置的任何其他代码可见
- exported 对可加载模块可见

当然，LKM 内部也可定义这三种符号
- static (标记为 `static` 的全局变量)的符号在符号表不可见
- external(无标记的全局变量)可见，但是是local变量
- exported(手动套了EXPORT_SYMBOL宏的全局变量)可见，且是全局的，可在 `__ksymtab` 和 `__kstrtab` 中看到

在LKM中可访问的模块都在内核某处进行了导出，如
```
 kernel/printk.c:EXPORT_SYMBOL(printk);
```

而所有导出的符号可以被称为内核接口或者内核API

